# Matrix Multiplication using Multi-threading with Pthreads

-----

## Overview

This program implements matrix multiplication using multiple threads to perform concurrent calculations. It leverages the pthread library in C to create threads that compute rows of the resultant matrix in parallel. The program allows user input for matrix dimensions and the number of threads to utilize.

## Key Features

  - **Multithreading with Pthreads**: Utilize multiple threads to perform matrix multiplication concurrently.
  - **User Input**: Accepts dimensions of matrices and the number of threads from the user.
  - **Dynamic Memory Allocation**: Dynamically allocates memory for matrices based on user-defined dimensions.
  - **Output**: Displays partial results for each row processed and the final resultant matrix.

## Requirements

  - **Compiler**: GCC (GNU Compiler Collection)
  - **Library**: pthread (POSIX Thread Library)

## Usage Instructions

### 1\. Compilation

To compile the program, use the following command in the terminal:

```bash
gcc -o m1 malmul.c -lpthread
```

### 2\. Execution

To run the program:

```bash
./m1
```

### 3\. Example Walkthrough

```bash
Enter dimensions M (rows of A), K (common dimension), N (columns of B): 
2 3 2
Enter number of threads: 
2
Enter elements of Matrix A (2 x 3):
A[0][0]: 1
A[0][1]: 2
A[0][2]: 3
A[1][0]: 4
A[1][1]: 5
A[1][2]: 6
Enter elements of Matrix B (3 x 2):
B[0][0]: 7
B[0][1]: 8
B[1][0]: 9
B[1][1]: 10
B[2][0]: 11
B[2][1]: 12
Partial result after computing row 0 by thread 0:
58.00 64.00 
Partial result after computing row 1 by thread 1:
139.00 154.00 
Final Result Matrix C (M x N):
58.00 64.00 
139.00 154.00 
Execution time: 0.001234 seconds
```

-----

# Producer-Consumer Matrix Multiplication

## Overview

This program implements a concurrent producer-consumer model using the pthread library in C. The program performs matrix multiplication using matrices generated by multiple producer threads and consumed by consumer threads. The producers place generated matrices into a bounded buffer, and consumers retrieve and multiply them. The program uses a fixed buffer size and employs synchronization mechanisms (mutexes and condition variables) to handle buffer access and maintain concurrency.

## Key Features

  - **Producer-Consumer Model**: Multiple producers generate matrices and store them in a bounded buffer. Consumers retrieve these matrices and perform matrix multiplication.
  - **Multithreading with pthreads**: Utilizes the pthread library to create multiple producer and consumer threads, enabling concurrent matrix production and multiplication.
  - **Synchronization**: Uses mutex locks and condition variables to handle thread synchronization, ensuring that threads correctly wait when the buffer is full or empty.

## Requirements

  - **Compiler**: GCC (GNU Compiler Collection)
  - **Library**: pthread (POSIX thread library)

## Usage Instructions

### 1\. Compilation

Compile the program using GCC with the pthread library:

```bash
gcc -o producer_consumer producer_consumer.c -lpthread
```

### 2\. User Input

The program will prompt for the following parameters:

  * **Buffer Size**: Number of slots available in the buffer for storing matrix pairs.
  * **Number of Producers**: Number of producer threads to create.
  * **Number of Consumers**: Number of consumer threads to create.
  * **Matrix Dimensions (M, K, N)**:
      * M: Number of rows in Matrix A.
      * K: Number of columns in Matrix A and rows in Matrix B.
      * N: Number of columns in Matrix B.
  * **Number of Operations**: Total number of matrices to produce and consume before terminating the threads.

## Code Explanation

### Structure of the Program

#### 1\. MatrixPair Structure

  - Defines a structure to hold two matrices (A and B), which are generated by producers and stored in the buffer.
  - Each matrix is dynamically allocated based on the user-provided dimensions.

#### 2\. Global Variables

  - **Buffer**: A circular buffer that holds MatrixPair structures.
  - **Indices `in` and `out`**: Track the insertion and removal points in the buffer.
  - **Count**: Tracks the number of items currently in the buffer.
  - **Produced and Consumed Counts**: Track the number of matrices produced and consumed, respectively.
  - **Mutex and Condition Variables**: Used to ensure proper synchronization of the buffer between producers and consumers.

### Function Descriptions

  - `generate_random_matrix`: Fills a given matrix with random values between 0 and 9.
  - `create_matrix_pair`: Allocates memory for a pair of matrices (A and B), generates random values for them, and returns the MatrixPair structure.
  - `producer`: Each producer thread:
      - Waits if the buffer is full.
      - Generates a matrix pair and places it into the buffer.
      - Signals consumers if they are waiting.
      - Terminates after producing a set number of matrices (determined by NUM\_OPERATIONS).
  - `consumer`: Each consumer thread:
      - Waits if the buffer is empty.
      - Removes a matrix pair from the buffer.
      - Performs matrix multiplication on matrices A and B to produce result C.
      - Frees the memory allocated for matrices A and B after computing C.
      - Terminates after consuming a set number of matrices (determined by NUM\_OPERATIONS).

### Main Function

  - Reads user input for buffer size, matrix dimensions, number of threads, and number of operations.
  - Validates all inputs to ensure they are positive and within reasonable limits.
  - Creates NUM\_PRODUCERS producer threads and NUM\_CONSUMERS consumer threads.
  - Waits for all producer and consumer threads to complete.
  - Frees any dynamically allocated memory after all operations are complete.

## Key Concepts and Synchronization Mechanisms

  - **Mutex Lock (`pthread_mutex_t mutex`)**:
      - Protects shared variables (`in`, `out`, `count`) from race conditions.
      - Ensures only one thread can access critical sections where shared data is modified.
  - **Condition Variables**:
      - `not_full`: Used by producers to wait when the buffer is full. Producers are signaled when a consumer removes a matrix from the buffer.
      - `not_empty`: Used by consumers to wait when the buffer is empty. Consumers are signaled when a producer adds a matrix to the buffer.

## Edge Cases and Error Handling

1.  **Input Validation**:
      - Checks for negative or zero values in buffer size, matrix dimensions, thread count, and operation count to prevent invalid inputs.
2.  **Memory Allocation Failure**:
      - Checks for successful memory allocation when creating matrices and the buffer.
      - If memory allocation fails, the program exits with an error message.
3.  **Buffer Overflow and Underflow**:
      - Uses condition variables to ensure producers wait when the buffer is full and consumers wait when itâ€™s empty, preventing overflow and underflow conditions.
4.  **Thread Termination Condition**:
      - The program allows only a specified number of operations (matrix pairs) to be produced and consumed, ensuring threads terminate after reaching this limit.
5.  **Cleanup**:
      - All allocated memory for matrices and the buffer is freed before program termination to prevent memory leaks.

## Potential Modifications

  - **Dynamic Termination**: Adjust the termination condition to allow dynamic stopping based on user-defined criteria.
  - **Performance Measurement**: Add timing code to measure performance metrics, such as time taken per matrix multiplication.
  - **Logging**: Introduce logging to a file for tracking thread activity, buffer state, and results.

## Troubleshooting

  - **Deadlock**: If the program appears stuck, ensure that buffer size, producer, and consumer counts are reasonable.
  - **Memory Leaks**: Check that all allocated memory is freed after use, particularly in error-handling branches.
  - **High CPU Usage**: If CPU usage is high, try reducing the number of producers or consumers, or adjusting the sleep time in the `producer` function.